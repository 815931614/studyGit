# 面试题

### Python中\__init__和\__new__的区别

- **__new__ 是在实例创建之前被调用的，因为他的任务就是创建实例然后返回该实例对象，是个静态方法。**

- **\__init__ 是当实例对象创建完毕之后被调用的，然后设置对象属性的一些初始值，通常用在初始化一个类实例的时候。是一个实例方法**

- **主要区别在于：\__new__是用来构造一个类的实例的，而\__init__是用来初始化一个实例的**

- **先调用new，后调用init，new的返回值将传递给init方法，init给这个实例设置一些参数**

- **继承至object的新式类才能有new，new至少有一个参数cls，代表当前类**

- **new必须要有返回值，返回实例化出来的实例，可以return父类new出来的实例，在定义子类时没有重新定义new时，Python默认调用该类的new方法构造该类的实例，如果该类的父类没有重写new，将一直追溯至object的new方法**

- **new的作用：继承一些不可变的class时，比如int，str，tuple，只有重载它的new方法才能起到修改自定义的作用**

  - 依照Python官方文档的说法，__new__方法主要是当你继承一些不可变的class时(比如int, str, tuple)， 提供给你一个自定义这些类的实例化过程的途径。还有就是实现自定义的metaclass。

  - 首先我们来看一下第一个功能，具体我们可以用int来作为一个例子：

  - 假如我们需要一个永远都是正数的整数类型，通过集成 int，我们可能会写出这样的代码。

    ```python
    class PositiveInterger(int):
    	def __init__(self,value):
    		super(PositiveInterger,self).__init__(self,abs(value))
    	
    
    print(PositiveInterger(-3))
    ```

    但运行后会发现，结果根本不是我们想的那样，我们任然得到了-3。这是因为对于int这种 不可变的对象，我们只有重载它的__new__方法才能起到自定义的作用。
    这是修改后的代码：

    ```python
    class PositiveInterger(int):
    	def __new__(cls,value):
    		return super(PositiveInterger,cls).__init__(cls,abs(value))
    	
    print(PositiveInterger(-3))
    ```

    

  

### 整个爬虫的工作流程(如何运作)

1. 请求目标链接

   发起一个带有header、请求参数等信息的Request，等待服务器响应

2. 获取响应内容

   服务器正常响应后，Response的内容即包含所有页面内容(可能是HTML，JSON字符串，二进制数据(图片，视频等)等等)

3. 解析内容

   得到的内容可能是HTML，可以用正则表达式，页面解析库进行解析；可能是JSON字符串，可以直接转换为JSON对象解析，可能是二进制数据，可以做保存或者进一步的处理

4. 存储形式多样，可以存为文本、也可以存储到数据库，或者存为特定格式的文件；

### HTTP的响应码

- **1xx 表示【临时响应】并需要请求者继续执行操作的状态代码**

  - `100(继续)`请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。
  - `101(切换协议)`请求者已要求服务器切换协议，服务器已确认并准备切换。

- **2xx 表示【成功】处理了请求的状态代码**

  - 200(成功)服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。

  - 201(已创建)请求成功并且服务器创建了新的资源。
  - 202(已接受)服务器已接受请求，但尚未处理。
  - 203(非授权信息)服务器已成功处理了请求，但返回的信息可能来自另一来源。
  - 204(无内容)服务器成功处理了请求，但没有返回任何内容。
  - 205(重置内容)服务器成功处理了请求，但没有返回任何内容。
  - 206(部分内容)服务器成功处理了部分 GET 请求。

- **3xx 表示要完成请求，需要进一步操作。通常，这些状态代码用来【重定向】**

  - 300(多种选择)针对请求，服务器可执行多种操作。服务器可根据请求者(user agent)选择一项操作，或提供操作列表供请求者选择。
  - 301(永久移动)请求的网页已永久移动到新位置。服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。
  - 302(临时移动)服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
  - 303(查看其他位置)请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
  - 304(未修改)自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。
  - 305(使用代理)请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。
  - 307(临时重定向)服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

- **4xx 表示【请求可能出错】，妨碍了服务器的处理**

  - 400(错误请求)表示客户端请求的语法错误，服务器无法理解，例如 url 含有非法字符、json 格式有问题。

  - 401(未授权)请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。
  - 402表示保留，将来使用。
  - 403(禁止)表示服务器理解请求客户端的请求，但是拒绝请求。
  - 404(未找到)服务器无法根据客户端的请求找到资源(网页)。
  - 405(方法禁用)禁用请求中指定的方法。
  - 406(不接受)无法使用请求的内容特性响应请求的网页。
  - 407(需要代理授权)此状态代码与 401(未授权)类似，但指定请求者应当授权使用代理。
  - 408(请求超时)服务器等候请求时发生超时。
  - 409(冲突)服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。
  - 410(已删除)如果请求的资源已永久删除，服务器就会返回此响应。
  - 411(需要有效长度)服务器不接受不含有效内容长度标头字段的请求。
  - 412(未满足前提条件)服务器未满足请求者在请求中设置的其中一个前提条件。
  - 413(请求实体过大)表示响应实在太大。服务器拒绝处理当前请求，请求超过服务器所能处理和允许的最大值。
  - 414(请求的 URI 过长)请求的 URI(通常为网址)过长，服务器无法处理。
  - 415(不支持的媒体类型)请求的格式不受请求页面的支持。
  - 416(请求范围不符合要求)如果页面无法提供请求的范围，则服务器会返回此状态代码。
  - 417(未满足期望值)在请求头 Expect 指定的预期内容无法被服务器满足(力不从心)。
  - 418表示我是一个茶壶。超文本咖啡馆控制协议，但是并没有被实际的 HTTP 服务器实现。
  - 420表示方法失效
  - 422表示不可处理的实体。请求格式正确，但是由于含有语义错误，无法响应。

- 5xx 表示【服务器】在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错

  - 500(服务器内部错误)服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。

  - 501(尚未实施)服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。

  - 502(错误网关)服务器作为网关或代理，从上游服务器收到无效响应。

  - 503(服务不可用)服务器目前无法使用(由于超载或停机维护)。通常，这只是暂时状态。

  - 504(网关超时)服务器作为网关或代理，但是没有及时从上游服务器收到请求。

  - 505(HTTP 版本不受支持)服务器不支持请求中所用的 HTTP 版本。

    

### 进程、线程、协程的区别

- **简介**

  1. 进程是资源分配的单位
  2. 线程是CPU调度的单位
  3. 协程是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制(也就是在用户态执行)

- **线程与进程区别**

  1. 地址空间：线程是进程内的一个执行单位，进程内至少有一个线程，他们共享进程的地址空间，而进程有自己独立的地址空间
  2. 资源拥有：进程是资源分配和拥有的单位，同一个进程内的线程共享进程的资源
  3. 线程是处理器调度的基本单位，但进程不是
  4. 二者均可以并发执行
  5. 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制

- 协程与线程的区别

  1. 一个线程中可以有多个协程，一个进程也可以单独拥有多个协程

  2. 线程进程都是同步机制，而协程则是异步。

  3. 协程能保留上一次调用的状态，每次过程重入时，就相当于进入上一次调用的状态

  4. 线程是抢占式，而协程是非抢占式的，所有需要用户自己释放使用权来切换其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。

  5. 协程并不是取代线程，而是抽象于线程之上。线程是被分割的CPU资源，协程是组织好的代码流程，协程需要线程来承载运行，线程是协程的资源，但协程不会直接使用线程，协程直接利用的是执行器(Interceptor),执行器可以关联任意线程或线程池，可以使当前线程，UI线程，或新建线程

  6. 线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。

     Python中并发对应的是多线程或协程；并行对应的是多进程。

### 如何实现多线程和多进程

- 