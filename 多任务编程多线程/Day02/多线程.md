# 线程编程(Thread)

### 线程基本概念

1. 什么是线程
   1. 线程被称为轻量级的进程
   2. 线程可以使用计算机多个资源，是多任务编程方式
   3. 线程时系统分配内核的最小单元
   4. 线程可以理解为进程的分支任务
2. 线程特征
   1. 一个进程中可以包含多个线程
   2. 线程也是一个运行行为，消耗计算机资源
   3. 一个进程中的所有线程共享这个进程的资源
   4. 多个线程之间的运行互不影响各自运行
   5. 线程的创建和销毁消耗资源远小于进程
   6. 各个线程也有自己的ID等特征

### threading 模块创建线程

1. 创建线程对象

   ```
   from threading import Thread
   
   t = Thread()
   功能: 创建线程对象
   参数：target绑定线程函数
   			args 元祖 给线程函数位置传参
   			kwargs 字典 给线程函数键值传参
   ```

2. 启动线程

   ```
   t.start()
   ```

3. 回收线程

   ```
   t.join([timeout])
   ```

线程对象属性

``` 
t.name 线程名称
t.setName() 设置线程名称
t.getName() 获取线程名称

t.is_alive() 查看线程是否在生命周期

t.daemon 设置主线程和分支线程的退出关系
t.setDaemon() 设置daemon属性值
t.isDaemon() 查看daemon属性值
 	daemon 为True时主线程退出分支线程也退出。要在start前设置，通常不和join一起使用
```

### 自定义线程类

1. 创建步骤
   1. 继承Thread类
   2. 重写\__init__方法添加自己的属性，使用super加载父类属性
   3. 重写run方法
2. 使用方法
   1. 实例化对象
   2. 调用start自动执行run方法
   3. 调用join回收线程

#### 同步互斥

#### 线程间通信方法

1. 通信方法

   线程间使用全局变量进行通信

2. 共享资源争夺

   - 共享资源：多个进程或着线程都可以操作的资源称为共享资源。对共享资源的操作代码称为临界区。
   - 影响：对共享资源的无序操作可能会带来数据的混乱，或者操作错误。此时往往需要同步互斥机制协调操作顺序。

3. 同步互斥机制

   同步：同步一种协作关系，为完成操作，多进程或者线程间形成一种协调，按照必要的步骤有序执行操作。

   互斥：互斥是一种约束关系，当一个进程或者线程占有资源时会进行加琐处理，此时其他进程就无法操作该资源，直到解锁后才能操作。

### 线程同步互斥方法

### 线程Event

```
from threading import Event
e = Event() 						# 创建新线程event对象
e.wati([timeout]) 			# 阻塞等待e被set
e.set() 								# 设置e, 使wait结束阻塞
e.clear() 							  # 使用e回到未被设置状态
e.is_set()   						# 查看当前e是否被设置
```

### 线程锁Lock

```
from threading import Lock

lock = Lock() 创建对象锁
lock.acquire() 上锁 如果lock已经上锁再调用会阻塞
lock.release() 解锁

with lock: 上锁
	with 代码结束自动解锁
```

### 死锁及其处理

1. 定义

   死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，他们都将无法推进下去，此时称系统处于死锁状态或系统产生了死锁

2. 解决
   使用定时锁

   使用重入锁Rlock(),用法同Lock。Rlock内部维护着一个Lock和counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。

#### python线程GIL

1. python线程的GIL问题(全局解释器锁)

   什么是GIL ： 由于python解释器设计中加入了解释器锁，导致python解释器同一时刻只能解释执行一个线程，大大降低了线程的执行效率。

   导致后果：因为遇到阻塞时线程会主动让出解释器，去解释其他线程。所以python多线程在执行多阻塞高延迟IO时可以提升程序效率，其他情况不能对效率有所提升

​		GIL问题建立

​				尽量使用进程完成无阻塞的并发行为

​				不使用C作为解释器(Java C#)